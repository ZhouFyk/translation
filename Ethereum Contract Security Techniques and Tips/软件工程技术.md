# 以太坊最佳实践翻译四

## 软件工程技术

如我们在[常规理念](https://consensys.github.io/smart-contract-best-practices/software_engineering/#general-philosophy)中讨论的一样，其不足以保护你来抵御已知的攻击。由于区块链上的失败成本可能非常高，因此您还必须调整自己编写软件的方式，以解决该风险。

我们主张的方式是 “做好失败的准备”。不可能提前知道你的代码是否安全。但是，你可以以使其能够优雅地失败并且损失最小的方式来构建你的合约。本部分提出了多种技术来帮助你为失败做好准备。

注意：当你新增一个组件到你的系统中时，总是伴随着一定的风险。一个不好的防故障设计本身可能会成为一个漏洞 - 当它与大量优秀的防故障设计交互时。请仔细考虑你在合约中使用的每种技术，并仔细考虑它们是如何协同合作以创建一个健壮的系统。

### 改进被破坏的合约

当错误发生或者需要做升级的时候，代码会需要被更改。当发现一个 bug 却无法处理的时候，十分糟糕。

为智能合约设计一个有效的改进系统是一个十分活跃的研究领域，而我们不会覆盖本文档中的所有难题。但是，存在两种最常用的基本方法。其中更简单的一种是使用一个注册合约来持有最新版本合约的地址。对于合约用户来说，更连贯的方法是拥有一份可以将调用和数据转发到合约的最新版本的合约。

不管是什么技术，模块化和组件间良好的分离是十分重要的，这样代码的修改就不会破坏功能，独立的数据，或者需要大量成本来移植。尤其是将复杂的逻辑从你的数据存储分离通常是有益的，这样你就不需要为了修改功能而重新创建所有的数据。

提供一种安全的方式可以让多方去决定升级代码也十分重要。由你的合约决定，代码修改被通过的前提是只需要一方可信的，一个团队，或者是所有股东的投票才可以。如果这个过程需要一些时间，你需要考虑是否有其他方法可以在发生攻击时迅速做出反应，如[紧急停止或者是熔断机制](https://github.com/ConsenSys/smart-contract-best-practices/#circuit-breakers-pause-contract-functionality)。

**示例 1:使用一个注册合约来存储另一个合约的最新版本**

在这个例子中，调用不会被发送，所以用户应该在每一次与合约交互之前都获取一下当前的地址。
```
contract SomeRegister {
	address backendContract;
	address[] previousBackends;
	address owner;

	function SomeRegister() {
		owner = msg.sender;
	}

	modifier onlyOwner() {
		require(msg.sender == owner)
		_;
	}

	function changeBackend(address newBackend) public onlyOwner() returns (bool) {
		if (newBackend != backendContract) {
			previousBackend.push(backendContract);
			backendContract = newBackend;
			return true;
		}

		return false;
	}
}
```

这个方法有两个缺点：

1. 用户必须总是检查当前的地址，如果不这么做就有使用旧版本合约的风险。
2. 你需要在替换合约的时候小心的思考如果处理合约内的数据。

另一种方法是让合约将调用和数据转发给合约的最新版本：

**示例 2：[使用 `DELEGATECALL`](http://ethereum.stackexchange.com/questions/2404/upgradeable-contracts) 来转发数据和调用**
```
contract Relay　{
	address public currentVersion;
	address public owner;

	modifier onlyOwner() {
		require(msg.sender == owner);
		_;
	}

	function Relay(address initAddr) {
		currentVersion = initAddr;
		owner = msg.sender; // this owner may be another contract with multisig, not a single contract owner
	}

	function changeContract(address newVersion) public onlyOwner() {
		currentVersion = newVersion;
	}

	function() {
		require(currentVersion.delegatecall(msg.data));
	}
}
```

这种方式避免了之前的问题，但是也有它自身存在的问题。你在合约中存储数据的时候必须极其小心。如果你的新合约与第一个的存储布局不同，你的数据最终可能被损坏。此外，这种模式的简单版本不能返回函数的值，只能转发它们，这限制了它的适用性。（[更多复杂的实现](https://github.com/ownage-ltd/ether-router)试图解决）