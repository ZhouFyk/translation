# 以太坊最佳实践翻译三

## 已知攻击

以下列出了你应该知道的已知攻击，并且在编写智能合约的时候进行防御。

### [竞争条件](https://consensys.github.io/smart-contract-best-practices/known_attacks/#footnote-race-condition-terminology)(Race Conditions)

调用外部合约的一个主要危险之一是它会接管控制流，并且修改调用方法不被 期望修改的数据。这种类型的 bug 有很多形式，导致 DAO 崩溃的两个主要错误都是这类错误。

#### 重入(Reentrancy)

这个 bug 的第一个版本需要注意，这个函数可以在函数第一次调用完成之前重复调用。 这可能会导致函数的不同调用以破坏性方式进行交互。
```
// insecure

mapping(address => uint) private userBalances;

function withdrawBalance() public {
	uint amountToWithdraw = userBalances[msg.sender];
	require(msg.sender.call.value(amountToWithdraw)()); // At this point, the call's code is executed, and can call withdrawBalance again
	userBalances[msg.sender] = 0;
}
```

因为用户余额直到最后被提取完才会被设置成 0，所以第二次（和更之后）的调用仍然会成功，从而一次又一次地提取余额。一个非常类似的 bug 是 DAO 攻击中的一个漏洞。

在给出的例子中，避免这个问题的最好的办法是通过 [使用 `send()` 代替 `call.value()()`](https://consensys.github.io/smart-contract-best-practices/recommendations#send-vs-call-value)。这会防止执行中的任何外部代码。

然而，如果你不能移除外部调用，下一个简单地防止此攻击的方法是确保直到你完成了所有的内部工作之前都没有调用外部函数，你需要做：
```
mapping(address => uint) private userBalances;

function withdrawBalance() public {
	uint amountToWithdraw = userBalances[msg.sender];
	userBalances[msg.sender] = 0;
	require(msg.sender.call.value(amountToWithdraw)());
}
```

注意，如果你有另一个调用了 `withdrawBalance()`的函数，它可能会受到相同的攻击，所以你必须对调用了不可信合约的函数也视为不可信。请参阅下方的潜在解决方案的进一步讨论。

#### 函数交叉竞争条件(Cross-function Race Conditions)

一个攻击者可能使用通过两个不同的函数共享一个状态来进行类似的攻击。

```
// insecure

mapping(address => uint) private userBalances;

function transfer(address to, uint amount) {
	if (userBalances[msg.sender] >= amount) {
		userBalance[to] += amount;
		userBalance[msg.sender] -= amount;
	}
}

function withdrawBalance() public {
	uint amountToWithdraw = userBalances[msg.sender];
	require(msg.sender.call.value(amountToWithdraw)()); // At this point, the caller's code is executed, and can call transfer()
	userBalances[msg.sender] = 0;
}
```

在这个例子中，当攻击者的代码在 `withdrawBalance()` 中的外部调用中被执行，攻击者会调用 `transfer()`。只要他们的余额不是 0，那么他们就可以在已经收到过一次提币的情况下，再次转移 token。 